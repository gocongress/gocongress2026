name: Mark Stale Issues

on:
  schedule:
    - cron: "30 2 * * *"
  workflow_dispatch:

jobs:
  mark-stale:
    runs-on: ubuntu-latest
    permissions:
      issues: write

    steps:
      - name: Generate App Token
        id: generate_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Process Stale Issues
        uses: actions/github-script@v7
        env:
          PROJECT_NUMBER: ${{ vars.PROJECT_NUMBER }}
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            const projectNumber = Number(process.env.PROJECT_NUMBER);
            const now = new Date();
            
            // Configuration
            const DAYS_DEFAULT = 14;
            const DAYS_LONG = 30;
            const STALE_LABEL = "stale";

            // Helper to extract Start Date from Project Items
            function getStartDateFromItems(nodes) {
              if (!nodes) return null;
              const item = nodes.find(i => i.project?.number === projectNumber);
              if (!item) return null;
              
              const dateVal = item.fieldValues.nodes.find(f => f.field?.name === "Start Date")?.date;
              return dateVal ? new Date(dateVal) : null;
            }

            // 1. Fetch all open issues
            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner: context.repo.owner, repo: context.repo.repo, state: "open" }
            );

            console.log(`Found ${issues.length} open issues.`);

            for (const issue of issues) {
              try {
                const isStale = issue.labels.some(l => l.name === STALE_LABEL);

                // 2. Fetch GraphQL Data (Self + Parent + Activity)
                const query = `
                  query($owner: String!, $repo: String!, $number: Int!) {
                    repository(owner: $owner, name: $repo) {
                      issue(number: $number) {
                        # Self Start Date
                        projectItems(first: 10) {
                          nodes {
                            project { number }
                            fieldValues(first: 20) {
                              nodes {
                                ... on ProjectV2ItemFieldDateValue {
                                  field { ... on ProjectV2FieldCommon { name } }
                                  date
                                }
                              }
                            }
                          }
                        }
                        # Parent Start Date (TrackedInIssues)
                        trackedInIssues(first: 1) {
                          nodes {
                            projectItems(first: 10) {
                              nodes {
                                project { number }
                                fieldValues(first: 20) {
                                  nodes {
                                    ... on ProjectV2ItemFieldDateValue {
                                      field { ... on ProjectV2FieldCommon { name } }
                                      date
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        # Activity Check
                        trackedIssues(first: 20) {
                          nodes {
                            updatedAt
                            trackedIssues(first: 10) {
                              nodes { updatedAt }
                            }
                          }
                        }
                      }
                    }
                  }
                `;
                
                const data = await github.graphql(query, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  number: issue.number
                });

                const issueData = data.repository.issue;

                // 3. Determine Effective Start Date
                let startDate = getStartDateFromItems(issueData.projectItems.nodes);
                
                // Fallback to Parent if no start date found
                if (!startDate && issueData.trackedInIssues.nodes.length > 0) {
                  startDate = getStartDateFromItems(issueData.trackedInIssues.nodes[0].projectItems.nodes);
                }

                // 4. RULE: No Start Date = Protected (Cleanup & Skip)
                if (!startDate) {
                  if (isStale) {
                    console.log(`Issue #${issue.number}: No Start Date (Self or Parent). Removing stale.`);
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      name: STALE_LABEL
                    });
                  }
                  continue; // Skip further processing
                }

                // 5. RULE: Future Start Date = Protected (Cleanup & Skip)
                if (startDate > now) {
                  if (isStale) {
                    console.log(`Issue #${issue.number}: Start Date is in future. Removing stale.`);
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      name: STALE_LABEL
                    });
                  }
                  continue; // Skip further processing
                }

                // 6. Check Activity
                // Calculate threshold
                const days = issue.labels.some(l => l.name === 'long-task') ? DAYS_LONG : DAYS_DEFAULT;
                const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

                // --- CHECK 6a: Self Update (LOOP FIX) ---
                // If the issue is NOT stale, we check if it was updated recently.
                // If the issue IS stale, we IGNORE the update time here, because the last update 
                // was likely the Bot itself. We rely on the 'issue_comment' job to un-stale via comments.
                if (!isStale && new Date(issue.updated_at) >= cutoff) {
                   continue; // It is active, do not mark stale
                }

                // --- CHECK 6b: Child/Grandchild Activity (Transitive) ---
                // It IS safe to un-stale based on children, because the bot comment on the parent
                // does not change the updatedAt timestamp of the children.
                let hasActiveChild = false;
                const children = issueData.trackedIssues.nodes;
                
                // Check direct children
                if (children.some(child => new Date(child.updatedAt) >= cutoff)) {
                  hasActiveChild = true;
                } else {
                  // Check grandchildren
                  hasActiveChild = children.some(child => 
                    child.trackedIssues.nodes.some(grandChild => new Date(grandChild.updatedAt) >= cutoff)
                  );
                }

                if (hasActiveChild) {
                  if (isStale) {
                    console.log(`Issue #${issue.number}: Active (children updated). Removing stale.`);
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      name: STALE_LABEL
                    });
                  }
                  continue; // Skip further processing
                }

                // 7. Mark Stale (Only if currently NOT stale)
                if (!isStale) {
                  console.log(`Marking issue #${issue.number} as stale.`);
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: [STALE_LABEL]
                  });

                  if (issue.assignee) {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `@${issue.assignee.login} This issue has gone stale. Please update or comment to keep it active.`
                    });
                  }
                }

              } catch (error) {
                console.log(`Error processing #${issue.number}: ${error.message}`);
              }
            }

  remove-stale-on-comment:
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment'
    permissions:
      issues: write

    steps:
      - name: Generate App Token
        id: generate_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Remove stale label when comment added
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            const issue = context.payload.issue;
            if (issue.labels.some(l => l.name === "stale")) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                name: "stale"
              });
            }
